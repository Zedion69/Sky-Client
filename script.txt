local lengthtabthing = 130
local screenGui = Instance.new("ScreenGui")
screenGui.Parent = game.CoreGui

local frame = Instance.new("Frame")
frame.Size = UDim2.new(1, 0, 0, 50)
frame.Position = UDim2.new(0, 0, 0, 0)
frame.BackgroundTransparency = 1
frame.Parent = screenGui

local textLabel = Instance.new("TextLabel")
textLabel.Size = UDim2.new(1, 0, 1, 0)
textLabel.Position = UDim2.new(0, 0, 0, 0) 
textLabel.BackgroundTransparency = 1 
textLabel.Text = "Sky Client V1.0: https://github.com/Zedion69/Sky-Client" 
textLabel.TextTransparency = 0.5
textLabel.TextColor3 = Color3.fromRGB(255, 255, 255) 
textLabel.TextSize = 20
textLabel.Font = Enum.Font.Gotham
textLabel.TextStrokeTransparency = 1
textLabel.Parent = frame

-- if this code looks ai generated i couldn't fix a bug in my code, i checked everywhere and decided to use ai to help me fix my script. (it changed some stuff tho)
game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "‚ö†Ô∏è WARNING ‚ö†Ô∏è ", -- Required
	Text = "This script was SPECIFICALLY designed for MOBILE DEVICES, not COMPUTER DEVICES.", -- Required
})
game:GetService("StarterGui"):SetCore("SendNotification",{
	Title = "üëë OWNER üëë", -- Required
	Text = "The owner of this script is zodien, you can DM me at: @zedion09", -- Required
})
local enablestartupsound = true
local enablebackgroundsound = true

local player = game.Players.LocalPlayer
local playerGui = player:FindFirstChild("PlayerGui")

if playerGui then
    local screenGui = Instance.new("ScreenGui")
    screenGui.Parent = game.CoreGui

    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(1, 0, 1, 0)
    frame.Position = UDim2.new(0, 0, 0, 0)
    frame.BackgroundColor3 = Color3.fromRGB(206, 157, 255)
    frame.BorderSizePixel = 0
    frame.BackgroundTransparency = 0
    frame.Parent = screenGui

    local frameGradient = Instance.new("UIGradient")
    frameGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(206, 157, 255)), 
        ColorSequenceKeypoint.new(1, Color3.fromRGB(255, 255, 255))  
    }
    frameGradient.Rotation = 145
    frameGradient.Parent = frame

    local textLabel = Instance.new("TextLabel")
    textLabel.Size = UDim2.new(0.5, 0, 0.2, 0)
    textLabel.Position = UDim2.new(0.25, 0, 0.4, 0)
    textLabel.BackgroundTransparency = 1
    textLabel.Text = "SKY CLIENT"
    textLabel.Font = Enum.Font.GothamBlack
    textLabel.TextSize = 100
    textLabel.TextColor3 = Color3.new(1, 1, 1)
    textLabel.TextTransparency = 0
    textLabel.Parent = frame

    local textGradient = Instance.new("UIGradient")
    textGradient.Color = ColorSequence.new{
        ColorSequenceKeypoint.new(0, Color3.fromRGB(255, 255, 255)), 
        ColorSequenceKeypoint.new(1, Color3.fromRGB(170, 170, 170))  
    }
    textGradient.Rotation = 90
    textGradient.Parent = textLabel

    wait(1)

    for i = 0, 100 do
        local alpha = i / 100
        frame.BackgroundTransparency = alpha
        textLabel.TextTransparency = alpha
        wait(0.01)
    end

    screenGui:Destroy()
end

if enablestartupsound then
    if not isfolder("skyclient/sounds") then
        makefolder("skyclient/sounds")
    end

    local url = "https://raw.githubusercontent.com/Zedion69/sounds/refs/heads/main/startup-87026%202.mp3"
    local filePath = "skyclient/sounds/startup.mp3"

    if not isfile(filePath) then
        writefile(filePath, game:HttpGet(url, true))
    end

    local Sound = Instance.new("Sound")
    Sound.SoundId = getcustomasset(filePath)
    Sound.Volume = 5
    Sound.Looped = false
    Sound.Parent = game:GetService("SoundService")
    Sound:Play()
end

makefolder("skyclient/images")

local imageUrl = "https://raw.githubusercontent.com/Zedion69/images/refs/heads/main/IMG_4234.jpeg"
local savePath = "skyclient/images/skyimage.png"

local imageData = game:HttpGet(imageUrl)
writefile(savePath, imageData)

local StarterGui = game:GetService("StarterGui")

StarterGui:SetCore("SendNotification", {
    Title = "Sky Client 1.0",
    Text = "Please be patient, the UI will load any second.",
    Icon = getcustomasset(savePath),
    Duration = 5,
})

local success, err = pcall(function()
    writefile("skyclient/sounds/background.mp3", game:HttpGet("https://raw.githubusercontent.com/Zedion69/sounds/refs/heads/main/Lukrembo%20-%20Memories%20(freetouse.com).mp3", true))
end)

if not success then
end

if enablebackgroundsound then
    if isfile("skyclient/sounds/background.mp3") then
        local Sound = Instance.new("Sound")
        Sound.SoundId = getcustomasset("skyclient/sounds/background.mp3")
        Sound.Volume = 0.3
        Sound.Looped = true
        Sound.Parent = game:GetService("SoundService")
        Sound:Play()
    end
end

local theme = Color3.fromRGB(180, 104, 255)
local Players = game:GetService("Players")
local player = Players.LocalPlayer
local playerGui = player:WaitForChild("PlayerGui")

local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Parent = playerGui
ScreenGui.ResetOnSpawn = false
ScreenGui.Enabled = true

local uiScale = 0.8  

local function adjustUIScale()
    for _, child in pairs(ScreenGui:GetChildren()) do
        if child:IsA("TextButton") then
            child.Size = UDim2.new(0, 120 * uiScale, 0, 30 * uiScale)
            child.TextSize = 14 * uiScale
        elseif child:IsA("Frame") then
            child.Size = UDim2.new(1, 0, 0, 30 * uiScale)
        end
    end
end

local function createTab(name, position)
    local tabButton = Instance.new("TextButton")
    tabButton.Parent = ScreenGui
    tabButton.Size = UDim2.new(0, 120 * uiScale, 0, 30 * uiScale)
    tabButton.Position = position or UDim2.new(0, 50, 0, 50)
    tabButton.BackgroundColor3 = theme
    tabButton.BackgroundTransparency = 0
    tabButton.Text = name
    tabButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    tabButton.Font = Enum.Font.GothamBold
    tabButton.TextSize = 14 * uiScale
    tabButton.AutoButtonColor = false
    tabButton.Active = true
    tabButton.Draggable = true
    tabButton.BorderSizePixel = 0
    tabButton.AnchorPoint = Vector2.new(0.5, 0)

    local gradient = Instance.new("UIGradient")
    gradient.Parent = tabButton
    gradient.Color = ColorSequence.new(
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(200, 200, 200)
    )
    gradient.Rotation = 90

    local dropdown = Instance.new("Frame")
    dropdown.Parent = tabButton
    dropdown.Size = UDim2.new(1, 0, 0, 0)
    dropdown.Position = UDim2.new(0, 0, 1, 0)
    dropdown.BackgroundTransparency = 1
    dropdown.ClipsDescendants = true
    dropdown.BorderSizePixel = 0
    
    local layout = Instance.new("UIListLayout")
    layout.Parent = dropdown
    layout.FillDirection = Enum.FillDirection.Vertical
    layout.SortOrder = Enum.SortOrder.LayoutOrder

    local expanded = false

    tabButton.MouseButton1Click:Connect(function()
        expanded = not expanded
        if expanded then
            dropdown:TweenSize(UDim2.new(1, 0, 0, #dropdown:GetChildren() * 30 * uiScale), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.5, true)
        else
            dropdown:TweenSize(UDim2.new(1, 0, 0, 0), Enum.EasingDirection.Out, Enum.EasingStyle.Quart, 0.5, true)
        end
    end)
    
    return dropdown
end

local function createToggle(name, parent, onActivate, onDeactivate)
    local option = Instance.new("TextButton")
    option.Parent = parent
    option.Size = UDim2.new(1, 0, 0, 30 * uiScale)
    option.BackgroundColor3 = Color3.fromRGB(33, 33, 33)
    option.BackgroundTransparency = 0
    option.Text = name
    option.TextColor3 = Color3.fromRGB(255, 255, 255)
    option.Font = Enum.Font.Gotham
    option.TextSize = 14 * uiScale
    option.BorderSizePixel = 0

    local gradient = Instance.new("UIGradient")
    gradient.Parent = option
    gradient.Color = ColorSequence.new(
        Color3.fromRGB(255, 255, 255),
        Color3.fromRGB(220, 220, 220)
    )
    gradient.Rotation = 90

    local toggled = false
    
    option.MouseButton1Click:Connect(function()
        toggled = not toggled
        if toggled then
            option.BackgroundColor3 = theme
            if onActivate then onActivate() end
        else
            option.BackgroundColor3 = Color3.fromRGB(33, 33, 33)
            if onDeactivate then onDeactivate() end
        end
    end)
end

local combat = createTab("Combat", UDim2.new(0, lengthtabthing + 50, 0, 50))
local blatant = createTab("Blatant", UDim2.new(0, lengthtabthing + 50 + 100, 0, 50))
local visual = createTab("Visual", UDim2.new(0, lengthtabthing + 50 + 100 + 100, 0, 50))
local world = createTab("World", UDim2.new(0, lengthtabthing + 50 + 100 + 100 + 100, 0, 50))

local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local tracerEnabled = false
local tracerLines = {}

local resetgravity = game.Workspace.Gravity

createToggle("Gravity", world, function()
    game.Workspace.Gravity = 80
end, function()
    game.Workspace.Gravity = resetgravity
end)

createToggle("Tracers", visual, function()
    tracerEnabled = true
end, function()
    tracerEnabled = false
    for _, line in pairs(tracerLines) do
        line:Remove()
    end
    tracerLines = {}
end)

game:GetService("RunService").RenderStepped:Connect(function()
    if tracerEnabled then
        for _, targetPlayer in pairs(game.Players:GetPlayers()) do
            if targetPlayer == player then
                continue
            end

            local character = targetPlayer.Character
            if character and character:FindFirstChild("Head") then
                local headPosition = camera:WorldToScreenPoint(character.Head.Position)

                if not tracerLines[targetPlayer] then
                    local line = Drawing.new("Line")
                    line.Thickness = 1
                    line.Color = Color3.fromRGB(180, 104, 255)
                    tracerLines[targetPlayer] = line
                end

                local line = tracerLines[targetPlayer]
                line.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
                line.To = Vector2.new(headPosition.X, headPosition.Y)
            end
        end
    else
        for _, line in pairs(tracerLines) do
            line:Remove()
        end
        tracerLines = {}
    end
end)

local isCFrameMovementEnabled = false

local function setupCharacter(character)
    local humanoid = character:WaitForChild("Humanoid")
    local hrp = character:WaitForChild("HumanoidRootPart")

    local walkSpeed = 1.5
    local speedMultiplier = walkSpeed / 5

    local function updateCFrame()
        local moveDirection = Vector3.new()
        if humanoid.MoveDirection.Magnitude > 0 then
            moveDirection = humanoid.MoveDirection.Unit
        end
        
        local moveVector = moveDirection * walkSpeed * speedMultiplier
        hrp.CFrame = hrp.CFrame + moveVector
    end

    game:GetService("RunService").Heartbeat:Connect(function()
        if isCFrameMovementEnabled then
            updateCFrame()
        end
    end)
end

createToggle("Speed", blatant, function()
    isCFrameMovementEnabled = true
end, function()
    isCFrameMovementEnabled = false
end)

player.CharacterAdded:Connect(function(character)
    setupCharacter(character)
end)

if player.Character then
    setupCharacter(player.Character)
end

createToggle("Teleport", blatant, function()
    local function teleportToNearestPlayer()
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local players = game.Players:GetPlayers()
            local nearestPlayer = nil
            local shortestDistance = math.huge
            
            for _, otherPlayer in pairs(players) do
                if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (player.Character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        nearestPlayer = otherPlayer
                        shortestDistance = distance
                    end
                end
            end

            if nearestPlayer then
                local tweenService = game:GetService("TweenService")
                local humanoidRootPart = player.Character.HumanoidRootPart
                local targetCFrame = nearestPlayer.Character.HumanoidRootPart.CFrame
                local tweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
                local tween = tweenService:Create(humanoidRootPart, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                tween.Completed:Wait()
            end
        end
    end

    teleportToNearestPlayer()

end, function()
    local function teleportToNearestPlayer()
        if player and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local players = game.Players:GetPlayers()
            local nearestPlayer = nil
            local shortestDistance = math.huge
            
            for _, otherPlayer in pairs(players) do
                if otherPlayer ~= player and otherPlayer.Character and otherPlayer.Character:FindFirstChild("HumanoidRootPart") then
                    local distance = (player.Character.HumanoidRootPart.Position - otherPlayer.Character.HumanoidRootPart.Position).Magnitude
                    if distance < shortestDistance then
                        nearestPlayer = otherPlayer
                        shortestDistance = distance
                    end
                end
            end

            if nearestPlayer then
                local tweenService = game:GetService("TweenService")
                local humanoidRootPart = player.Character.HumanoidRootPart
                local targetCFrame = nearestPlayer.Character.HumanoidRootPart.CFrame
                local tweenInfo = TweenInfo.new(0.01, Enum.EasingStyle.Sine, Enum.EasingDirection.Out)
                local tween = tweenService:Create(humanoidRootPart, tweenInfo, {CFrame = targetCFrame})
                tween:Play()
                tween.Completed:Wait()
            end
        end
    end

    teleportToNearestPlayer()

end)

local baseplate = Instance.new("Part")
baseplate.Size = Vector3.new(10000, 1, 10000)
baseplate.Position = Vector3.new(0, 71.98, 0)
baseplate.Anchored = true
baseplate.Color = Color3.fromRGB(180, 104, 255)
baseplate.Parent = game.Workspace

baseplate.Transparency = 1
baseplate.CanCollide = false

createToggle("Antivoid", blatant, function()
    baseplate.Transparency = 0.6
    baseplate.CanCollide = true
end, function()
    baseplate.Transparency = 1
    baseplate.CanCollide = false
end)

local edgeDistance = 0.5
local checkInterval = 0.01
local edgeCheckEnabled = false
local currentCheckTask = nil

local function isAtEdge(character)
    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return false end

    local rayOrigin = character.PrimaryPart.Position
    local rayDirection = Vector3.new(0, -5, 0)
    local raycastParams = RaycastParams.new()
    raycastParams.FilterDescendantsInstances = {character}
    raycastParams.FilterType = Enum.RaycastFilterType.Blacklist

    local raycastResult = workspace:Raycast(rayOrigin, rayDirection, raycastParams)
    if raycastResult and raycastResult.Instance then
        local part = raycastResult.Instance
        local size = part.Size
        local position = part.Position

        local minX = position.X - size.X / 2
        local maxX = position.X + size.X / 2
        local minZ = position.Z - size.Z / 2
        local maxZ = position.Z + size.Z / 2

        if math.abs(rayOrigin.X - minX) <= edgeDistance or math.abs(rayOrigin.X - maxX) <= edgeDistance or
           math.abs(rayOrigin.Z - minZ) <= edgeDistance or math.abs(rayOrigin.Z - maxZ) <= edgeDistance then
            return true
        end
    end
    return false
end

local function startEdgeCheck(character)
    if currentCheckTask then
        task.cancel(currentCheckTask)
    end

    local humanoid = character:FindFirstChildOfClass("Humanoid")
    if not humanoid then return end

    currentCheckTask = task.spawn(function()
        while edgeCheckEnabled and task.wait(checkInterval) do
            if not character or not character.Parent then break end
            if isAtEdge(character) and humanoid:GetState() ~= Enum.HumanoidStateType.Jumping then
                humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
            end
        end
    end)
end

player.CharacterAdded:Connect(function(character)
    task.wait(0.1)
    if edgeCheckEnabled then
        startEdgeCheck(character)
    end
end)

if player.Character then
    startEdgeCheck(player.Character)
end

createToggle("AutoJump", world, function()
    edgeCheckEnabled = true
    if player.Character then
        startEdgeCheck(player.Character)
    end
end, function()
    edgeCheckEnabled = false
end)

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
local RunService = game:GetService("RunService")

local detectionRange = 30
local swordName = "Sword"
local spinningEnabled = false
local heartbeatConnection

createToggle("Killaura", blatant, function()
    spinningEnabled = true
    detectionRange = 15
    startKillaura()
end, function()
    spinningEnabled = false
    detectionRange = 20
    stopKillaura()
end)

local function isPlayerNearby()
    for _, player in pairs(Players:GetPlayers()) do
        if player ~= LocalPlayer and player.Character and player.Character:FindFirstChild("HumanoidRootPart") then
            local humanoid = player.Character:FindFirstChild("Humanoid")
            local forceField = player.Character:FindFirstChild("ForceField")
            local distance = (LocalPlayer.Character.HumanoidRootPart.Position - player.Character.HumanoidRootPart.Position).Magnitude

            if humanoid and humanoid.Health > 0 and not forceField and distance <= detectionRange then
                return true
            end
        end
    end
    return false
end

local function equipSword()
    local sword = LocalPlayer.Backpack:FindFirstChild(swordName)
    if sword and not LocalPlayer.Character:FindFirstChild(swordName) then
        sword.Parent = LocalPlayer.Character
    end
end

local function unequipSword()
    local sword = LocalPlayer.Character:FindFirstChild(swordName)
    if sword then
        sword.Parent = LocalPlayer.Backpack
    end
end

local function useSword()
    local sword = LocalPlayer.Character:FindFirstChild(swordName)
    if sword and sword:IsA("Tool") then
        sword:Activate()
    end
end

local function spinPlayer()
    local humanoidRootPart = LocalPlayer.Character:FindFirstChild("HumanoidRootPart")
    if humanoidRootPart then
        humanoidRootPart.CFrame = humanoidRootPart.CFrame * CFrame.Angles(0, math.rad(0), 0)
    end
end

local function disablePlayerControls()
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid then
        print("s")
    end
end

local function enablePlayerControls()
    local humanoid = LocalPlayer.Character:FindFirstChild("Humanoid")
    if humanoid then
        humanoid.AutoRotate = true
    end
end

function startKillaura()
    heartbeatConnection = RunService.Heartbeat:Connect(function()
        if spinningEnabled and isPlayerNearby() then
            equipSword()
            useSword()
            local sword = LocalPlayer.Character:FindFirstChild(swordName)
            if sword then
                spinPlayer()
                disablePlayerControls()
            end
        else
            unequipSword()
            enablePlayerControls()
        end
    end)
end

function stopKillaura()
    if heartbeatConnection then
        heartbeatConnection:Disconnect()
        heartbeatConnection = nil
    end
    enablePlayerControls()
    unequipSword()
end

createToggle("ReachBypass", combat, function()
    local range = 12
    game:GetService("RunService").RenderStepped:Connect(function()
        local p = game.Players:GetPlayers()
        for i = 2, #p do 
            local v = p[i].Character
            if v and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 and v:FindFirstChild("HumanoidRootPart") and player:DistanceFromCharacter(v.HumanoidRootPart.Position) <= range then
                local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") then
                    tool:Activate()
                    for i, v in next, v:GetChildren() do
                        if v:IsA("BasePart") then
                            firetouchinterest(tool.Handle, v, 0)
                            firetouchinterest(tool.Handle, v, 1)
                        end
                    end
                end
            end
        end
    end)
end, function()
end)

local InfiniteJumpEnabled = false
game:GetService("UserInputService").JumpRequest:connect(function()
    if InfiniteJumpEnabled then
        game:GetService("Players").LocalPlayer.Character:FindFirstChildOfClass('Humanoid'):ChangeState("Jumping")
    end
end)

createToggle("AirJump", blatant, function()
    InfiniteJumpEnabled = true
end, function()
    InfiniteJumpEnabled = false
end)
local advertisespam = false
while advertisespam do
  wait(4)
  game.TextChatService.TextChannels.RBXGeneral:SendAsync("skyclient is cool")
end
createToggle("Advertise", blatant, function()
    advertisespam = true
end, function()
    advertisespam = false
end)

createToggle("InfiniteReach", blatant, function()
    local range = 5000000000000
    game:GetService("RunService").RenderStepped:Connect(function()
        local p = game.Players:GetPlayers()
        for i = 2, #p do 
            local v = p[i].Character
            if v and v:FindFirstChild("Humanoid") and v.Humanoid.Health > 0 and v:FindFirstChild("HumanoidRootPart") and player:DistanceFromCharacter(v.HumanoidRootPart.Position) <= range then
                local tool = player.Character and player.Character:FindFirstChildOfClass("Tool")
                if tool and tool:FindFirstChild("Handle") then
                    tool:Activate()
                    for i, v in next, v:GetChildren() do
                        if v:IsA("BasePart") then
                            firetouchinterest(tool.Handle, v, 0)
                            firetouchinterest(tool.Handle, v, 1)
                        end
                    end
                end
            end
        end
    end)
end, function()
end)

local oldfov = game:GetService("Workspace").CurrentCamera.FieldOfView

createToggle("FOV", visual, function()
    game:GetService("Workspace").CurrentCamera.FieldOfView = 120
end, function()
    game:GetService("Workspace").CurrentCamera.FieldOfView = oldfov
end)
adjustUIScale()

workspace.GameMusic:Destroy()
